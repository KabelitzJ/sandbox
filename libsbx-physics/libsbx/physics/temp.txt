#include <iostream>
#include <vector>
#include <array>
#include <limits>
#include <algorithm>

// A simple 3D vector class
template<typename T>
struct Vector3 {
    T x, y, z;

    Vector3() : x(T()), y(T()), z(T()) {}
    Vector3(T x, T y, T z) : x(x), y(y), z(z) {}

    bool operator==(const Vector3& other) const {
        return x == other.x && y == other.y && z == other.z;
    }

    Vector3 operator+(const Vector3& other) const {
        return Vector3(x + other.x, y + other.y, z + other.z);
    }

    Vector3& operator+=(const Vector3& other) {
        x += other.x;
        y += other.y;
        z += other.z;
        return *this;
    }

    Vector3 operator*(T scalar) const {
        return Vector3(x * scalar, y * scalar, z * scalar);
    }

    Vector3& operator*=(T scalar) {
        x *= scalar;
        y *= scalar;
        z *= scalar;
        return *this;
    }
};

// A class for axis-aligned bounding boxes
template<typename T>
class BoundingBox {
public:
    Vector3<T> min;
    Vector3<T> max;

    BoundingBox() 
        : min(Vector3<T>(std::numeric_limits<T>::max(), std::numeric_limits<T>::max(), std::numeric_limits<T>::max())),
          max(Vector3<T>(std::numeric_limits<T>::lowest(), std::numeric_limits<T>::lowest(), std::numeric_limits<T>::lowest())) {}

    BoundingBox(const Vector3<T>& min, const Vector3<T>& max) : min(min), max(max) {}

    bool contains(const Vector3<T>& point) const {
        return (point.x >= min.x && point.x <= max.x &&
                point.y >= min.y && point.y <= max.y &&
                point.z >= min.z && point.z <= max.z);
    }

    bool intersects(const BoundingBox& other) const {
        return (min.x <= other.max.x && max.x >= other.min.x &&
                min.y <= other.max.y && max.y >= other.min.y &&
                min.z <= other.max.z && max.z >= other.min.z);
    }

    auto get_octant(int index) const -> BoundingBox {
        auto center = (min + max) * T(0.5);
        switch(index) {
            case 0: return BoundingBox(min, center);
            case 1: return BoundingBox(Vector3<T>(center.x, min.y, min.z), Vector3<T>(max.x, center.y, center.z));
            case 2: return BoundingBox(Vector3<T>(min.x, center.y, min.z), Vector3<T>(center.x, max.y, center.z));
            case 3: return BoundingBox(Vector3<T>(center.x, center.y, min.z), Vector3<T>(max.x, max.y, center.z));
            case 4: return BoundingBox(Vector3<T>(min.x, min.y, center.z), Vector3<T>(center.x, center.y, max.z));
            case 5: return BoundingBox(Vector3<T>(center.x, min.y, center.z), Vector3<T>(max.x, center.y, max.z));
            case 6: return BoundingBox(Vector3<T>(min.x, center.y, center.z), Vector3<T>(center.x, max.y, max.z));
            case 7: return BoundingBox(center, max);
        }
        return BoundingBox();
    }
};

// Node structure
template<typename T, typename U>
class OctreeNode {
public:
    BoundingBox<T> bounds;
    std::vector<std::pair<U, BoundingBox<T>>> values;
    std::array<int, 8> children;

    OctreeNode(const BoundingBox<T>& bounds) : bounds(bounds) {
        children.fill(-1);
    }
};

// Octree class
template<typename T, typename U, size_t threshold, size_t max_depth>
class Octree {
private:
    std::vector<OctreeNode<T, U>> nodes;

public:
    Octree(const BoundingBox<T>& bounding_box) {
        nodes.emplace_back(bounding_box);
    }

    void insert(const U& value, const BoundingBox<T>& bounding_box) {
        insert(0, value, bounding_box, 0);
    }

    std::vector<U> query(const BoundingBox<T>& bounding_box) const {
        std::vector<U> result;
        query(0, bounding_box, result);
        return result;
    }

    std::vector<std::pair<U, U>> intersections() const {
        std::vector<std::pair<U, U>> result;
        intersections(0, result);
        return result;
    }

private:
    void insert(int node_index, const U& value, const BoundingBox<T>& bounding_box, size_t current_depth) {
        auto& node = nodes[node_index];

        if (current_depth >= max_depth) {
            node.values.emplace_back(value, bounding_box);
            return;
        }

        if (node.values.size() < threshold) {
            node.values.emplace_back(value, bounding_box);
            return;
        }

        if (node.children[0] == -1) {
            for (int i = 0; i < 8; ++i) {
                auto child_bounding_box = node.bounds.get_octant(i);
                node.children[i] = nodes.size();
                nodes.emplace_back(child_bounding_box);
            }
        }

        for (int i = 0; i < 8; ++i) {
            auto& child = nodes[node.children[i]];
            if (child.bounds.intersects(bounding_box)) {
                insert(node.children[i], value, bounding_box, current_depth + 1);
            }
        }
    }

    void query(int node_index, const BoundingBox<T>& bounding_box, std::vector<U>& result) const {
        const auto& node = nodes[node_index];

        if (!node.bounds.intersects(bounding_box)) {
            return;
        }

        for (const auto& value_pair : node.values) {
            if (bounding_box.intersects(value_pair.second)) {
                result.push_back(value_pair.first);
            }
        }

        if (node.children[0] != -1) {
            for (const auto& child_index : node.children) {
                if (child_index != -1) {
                    query(child_index, bounding_box, result);
                }
            }
        }
    }

    void intersections(int node_index, std::vector<std::pair<U, U>>& result) const {
        const auto& node = nodes[node_index];

        // Check intersections within the current node's values
        for (size_t i = 0; i < node.values.size(); ++i) {
            for (size_t j = i + 1; j < node.values.size(); ++j) {
                if (node.values[i].second.intersects(node.values[j].second)) {
                    result.emplace_back(node.values[i].first, node.values[j].first);
                }
            }
        }

        // Check intersections between children
        for (int i = 0; i < 8; ++i) {
            if (node.children[i] != -1) {
                intersections(node.children[i], result);

                for (int j = i + 1; j < 8; ++j) {
                    if (node.children[j] != -1) {
                        find_intersections_between_nodes(node.children[i], node.children[j], result);
                    }
                }
            }
        }
    }

    void find_intersections_between_nodes(int node_index1, int node_index2, std::vector<std::pair<U, U>>& result) const {
        const auto& node1 = nodes[node_index1];
        const auto& node2 = nodes[node_index2];

        for (const auto& value1 : node1.values) {
            for (const auto& value2 : node2.values) {
                if (value1.second.intersects(value2.second)) {
                    result.emplace_back(value1.first, value2.first);
                }
            }
        }

        for (int i = 0; i < 8; ++i) {
            if (node1.children[i] != -1) {
                for (int j = 0; j < 8; ++j) {
                    if (node2.children[j] != -1) {
                        find_intersections_between_nodes(node1.children[i], node2.children[j], result);
                    }
                }
            }
        }
    }
};

int main() {
    BoundingBox<float> root_bounding_box(Vector3<float>(0.0f, 0.0f, 0.0f), Vector3<float>(1.0f, 1.0f, 1.0f));
    Octree<float, Vector3<float>, 4, 5> octree(root_bounding_box);

    octree.insert(Vector3<float>(0.1f, 0.1f, 0.1f), BoundingBox<float>(Vector3<float>(0.1f, 0.1f, 0.1f), Vector3<float>(0.2f, 0.2f, 0.2f)));
    octree.insert(Vector3<float>(0.15f, 0.15f, 0.15f), BoundingBox<float>(Vector3<float>(0.15f, 0.15f, 0.15f), Vector3<float>(0.25f, 0.25f, 0.25f)));
    octree.insert(Vector3<float>(0.3f, 0.3f, 0.3f), BoundingBox<float>(Vector3<float>(0.3f, 0.3f, 0.3f), Vector3<float>(0.4f, 0.4f, 0.4f)));
    octree.insert(Vector3<float>(0.35f, 0.35f, 0.35f), BoundingBox<float>(Vector3<float>(0.35f, 0.35f, 0.35f), Vector3<float>(0.45f, 0.45f, 0.45f)));

    auto result = octree.query(BoundingBox<float>(Vector3<float>(0.2f, 0.2f, 0.2f), Vector3<float>(0.3f, 0.3f, 0.3f)));

    std::cout << "Query results:" << std::endl;
    for (const auto& value : result) {
        std::cout << "(" << value.x << ", " << value.y << ", " << value.z << ")" << std::endl;
    }

    auto intersections_result = octree.intersections();
    std::cout << "Intersections:" << std::endl;
    for (const auto& pair : intersections_result) {
        std::cout << "Intersection between (" << pair.first.x << ", " << pair.first.y << ", " << pair.first.z << ") and ("
                  << pair.second.x << ", " << pair.second.y << ", " << pair.second.z << ")" << std::endl;
    }

    return 0;
}

