// #include <libsbx/common/lighting.slang>
// #include <libsbx/common/shadow.slang>
#include <libsbx/common/depth.slang>
#include <libsbx/common/constants.slang>

struct fs_in {
  float2 uv : TEXCOORD0;
  float4 sv_position : SV_Position;
}; // struct fs_in

struct fs_out {
  float4 color : SV_Target0;
}; // struct fs_out

struct scene_data {
  float3 camera_position;
  float3 light_direction;
  float4 light_color;
  float4x4 light_space;
  uint point_light_count;
}; // struct scene_data

[[vk::binding(0, 0)]]
ConstantBuffer<scene_data> scene;

struct point_light {
  float3 position;
  float4 color;
  float radius;
}; // point_light

[[vk::binding(1, 0)]]
StructuredBuffer<point_light> buffer_point_lights;

[[vk::binding(2, 0)]] Sampler2D albedo_image;
[[vk::binding(3, 0)]] Sampler2D position_image;
[[vk::binding(4, 0)]] Sampler2D normal_image;
[[vk::binding(5, 0)]] Sampler2D material_image;
[[vk::binding(6, 0)]] Sampler2D shadow_image;

static const float3 DEFAULT_F0 = float3(0.04, 0.04, 0.04);

static const float4x4 BIAS_MATRIX = float4x4(
  0.5, 0.0, 0.0, 0.0,
  0.0, 0.5, 0.0, 0.0,
  0.0, 0.0, 0.5, 0.0,
  0.5, 0.5, 0.5, 1.0
);

float3 fresnel_schlick(float cos_theta, float3 f0) {
  return f0 + (1.0 - f0) * pow(1.0 - cos_theta, 5.0);
}

float distribution_ggx(float3 n, float3 h, float roughness) {
  float a  = roughness * roughness;
  float a2 = a * a;

  float ndh  = max(dot(n, h), 0.0);
  float ndh2 = ndh * ndh;

  float denom = ndh2 * (a2 - 1.0) + 1.0;

  return a2 / (sbx::common::pi * denom * denom);
}

float geometry_schlick_ggx(float ndv, float roughness) {
  float r = (roughness + 1.0);
  float k = (r * r) / 8.0;

  return ndv / (ndv * (1.0 - k) + k);
}

float geometry_smith(float3 n, float3 v, float3 l, float roughness) {
  float ndv = max(dot(n, v), 0.0);
  float ndl = max(dot(n, l), 0.0);

  float ggx1 = geometry_schlick_ggx(ndv, roughness);
  float ggx2 = geometry_schlick_ggx(ndl, roughness);

  return ggx1 * ggx2;
}

// === Shadow Calculation ===
static const float2 POISSON_DISK[16] = {
  float2(-0.94201624, -0.39906216),
  float2( 0.94558609, -0.76890725),
  float2(-0.094184101, -0.92938870),
  float2( 0.34495938,  0.29387760),
  float2(-0.91588581,  0.45771432),
  float2(-0.81544232, -0.87912464),
  float2(-0.38277543,  0.27676845),
  float2( 0.97484398,  0.75648379),
  float2( 0.44323325, -0.97511554),
  float2( 0.53742981, -0.47373420),
  float2(-0.26496911, -0.41893023),
  float2( 0.79197514,  0.19090188),
  float2(-0.24188840,  0.99706507),
  float2(-0.81409955,  0.91437590),
  float2( 0.19984126,  0.78641367),
  float2( 0.14383161, -0.14100790)
};

float random2(float2 seed) {
  return frac(sin(dot(seed, float2(12.9898, 78.233))) * 43758.5453);
}

float2x2 rotation_matrix(float angle) {
  float s = sin(angle);
  float c = cos(angle);

  return float2x2(c, -s, s, c);
}

float calculate_shadow(float3 world_position, float3 normal) {
  float4 shadow_coord = mul(BIAS_MATRIX, mul(scene.light_space, float4(world_position, 1.0)));
  float3 projected_coords = shadow_coord.xyz / shadow_coord.w;

  if (projected_coords.z > 1.0) {
    return 1.0;
  }

  float bias = max(0.0005 * (1.0 - dot(normal, normalize(scene.light_direction))), 0.0001);

  uint2 dimensions;
  shadow_image.GetDimensions(dimensions.x, dimensions.y);

  float2 texel_size = 1.0 / dimensions;

  float distance_to_camera = length(scene.camera_position - world_position);
  float radius = lerp(1.0, 4.0, clamp(distance_to_camera / 50.0, 0.0, 1.0));

  float angle = random2(projected_coords.xy) * sbx::common::two_pi;
  float2x2 rotation = rotation_matrix(angle);

  float shadow = 0.0;

  [unroll]
  for (int i = 0; i < 16; ++i) {
    float2 offset = mul(rotation, POISSON_DISK[i]);
    float2 sample_uv = projected_coords.xy + offset * texel_size * radius;

    float sample_depth = shadow_image.Sample(sample_uv).r;

    shadow += (projected_coords.z - bias > sample_depth) ? 0.0 : 1.0;
  }

  return shadow / 16.0;
}

[noinline]
T keep<T>(T value) {
  return value;
}

[shader("fragment")]
fs_out main(fs_in in) {
  fs_out out;

  // --- G-buffer sampling ---
  float3 albedo = albedo_image.Sample(in.uv).rgb;
  float3 world_position = position_image.Sample(in.uv).xyz;
  float3 normal = normalize(normal_image.Sample(in.uv).xyz);
  float3 mrao = material_image.Sample(in.uv).rgb;

  float metallic  = clamp(mrao.r, 0.0, 1.0);
  float roughness = clamp(mrao.g, 0.05, 1.0);
  float ao = clamp(mrao.b, 0.0, 1.0);

  float3 view_dir = normalize(scene.camera_position - world_position);
  float3 f0 = lerp(DEFAULT_F0, albedo, metallic);

  float3 color = float3(0.0, 0.0, 0.0);

  // --- Directional Light ---
  float3 light_dir = normalize(-scene.light_direction);
  float3 halfway_dir = normalize(view_dir + light_dir);
  float ndl = max(dot(normal, light_dir), 0.0);

  float D = distribution_ggx(normal, halfway_dir, roughness);
  float G = geometry_smith(normal, view_dir, light_dir, roughness);
  float3 F = fresnel_schlick(max(dot(halfway_dir, view_dir), 0.0), f0);

  float3 numerator = D * G * F;
  float denominator = 4.0 * max(dot(normal, view_dir), 0.0) * ndl + 0.001;
  float3 specular = numerator / denominator;

  float3 k_s = F;
  float3 k_d = (1.0 - k_s) * (1.0 - metallic);

  keep(shadow_image);
  float shadow = 1.0; // calculate_shadow(world_position, normal);
  float3 irradiance = scene.light_color.rgb * ndl * shadow;

  color += (k_d * albedo / sbx::common::pi + specular) * irradiance;

  // --- Point Lights ---
  for (uint i = 0u; i < scene.point_light_count; ++i) {
    point_light light = buffer_point_lights[i];

    float3 l_dir = light.position - world_position;
    float  distance = max(length(l_dir), 0.001);

    l_dir /= distance;

    float3 h = normalize(view_dir + l_dir);
    float ndl_p = max(dot(normal, l_dir), 0.0);
    float attenuation = clamp(1.0 - distance / light.radius, 0.0, 1.0);

    attenuation *= attenuation;

    float3 radiance = light.color.rgb * light.color.a * attenuation;

    float Dp = distribution_ggx(normal, h, roughness);
    float Gp = geometry_smith(normal, view_dir, l_dir, roughness);
    float3 Fp = fresnel_schlick(max(dot(h, view_dir), 0.0), f0);

    float3 numerator_p = Dp * Gp * Fp;
    float denom_p = 4.0 * max(dot(normal, view_dir), 0.0) * ndl_p + 0.001;
    float3 spec_p = numerator_p / denom_p;

    float3 kd_p = (1.0 - Fp) * (1.0 - metallic);

    color += (kd_p * albedo / sbx::common::pi + spec_p) * radiance * ndl_p;
  }

  float3 ambient = float3(0.03, 0.03, 0.03) * albedo * ao;
  float3 final_color = ambient + color;

  out.color = float4(final_color, 1.0);

  return out;
}
